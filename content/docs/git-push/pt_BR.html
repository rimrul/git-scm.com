---
category: manual
section: documentation
subsection: manual
title: Git - git-push Documentation
docname: git-push
lang: pt_BR
aliases:
- "/docs/git-push/pt_BR"
- "/docs/git-push/pt_BR.html"

---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-push - Atualiza as refs remotas junto com os objetos associados a ela</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git push</em> [--all | --branches | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;]
	   [--repo=&lt;repositório&gt;] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]
	   [-u | --set-upstream] [-o &lt;string&gt; | --push-option=&lt;string&gt;]
	   [--[no-]signed|--signed=(true|false|if-asked)]
	   [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]] [--force-if-includes]]
	   [--no-verify] [&lt;repositório&gt; [&lt;refspec&gt;&#8230;&#8203;]]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Atualiza as refs remotas utilizando as refs locais, enquanto envia os objetos necessários para que seja concluída as refs informadas.</p>
</div>
<div class="paragraph">
<p>Você pode fazer com que coisas que intereçam aconteçam com um repositório toda vez que você o adiciona, configurando os <em>ganchos</em> lá. Consulte a documentação para <a href='{{< relurl "docs/git-receive-pack/pt_BR" >}}'>git-receive-pack[1]</a>.</p>
</div>
<div class="paragraph">
<p>Quando a linha de comando não informa para onde impulsionar (push) com a opção <code>&lt;repositório&gt;</code>, a configuração <code>branch.*.remote</code> é consultada para o ramo atual para determinar para onde o impulsionamento deve ser feito. Caso a configuração esteja ausente, a predefinição retorna para <em>origin</em>.</p>
</div>
<div class="paragraph">
<p>Quando a linha de comando não especifica o que impulsionar (push) com as opções <code>&lt;refspec&gt;...</code> ou com as opções <code>--all</code>, <code>--mirror</code>, <code>--tags</code>, o comando encontra a predefinição <code>&lt;refspec&gt;</code> consultando a configuração <code>remote.*.push</code> e caso ainda não tenha sido encontrado, honra a configuração do <code>push.default</code> para decidir o que enviar (para saber o significado de <code>push.default</code> consulte<a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</div>
<div class="paragraph">
<p>Quando nem a linha de comando nem a configuração informam o que enviar, o comportamento predefinido é utilizado, que corresponde ao valor <code>simple</code> para <code>push.default</code>: o ramo atual é enviado ao ramo upstream correspondente, porém como uma medida segurança, o envio será cancelado caso o ramo upstream não esteja com o mesmo nome que o ramo local.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES<a id="OPÇÕES"></a></h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-ltrepositriogt"> <a class="anchor" href="#git-push-ltrepositriogt"></a>&lt;repositório&gt; </dt>
<dd>
<p>O repositório "remoto" que é o destino de uma operação de envio através de uma operação "push". Este parâmetro pode ser uma URL (consulte a seção <a href="#URLS">GIT URLS</a> abaixo) ou o nome de um ramo remoto (consulte a seção <a href="#REMOTES">REMOTES</a> abaixo).</p>
</dd>
<dt class="hdlist1" id="git-push-ltrefspecgt82308203"> <a class="anchor" href="#git-push-ltrefspecgt82308203"></a>&lt;refspec&gt;&#8230;&#8203; </dt>
<dd>
<p>Defina qual a "ref" do destino para atualizar com qual objeto da origem. O formato de um parâmetro <code>&lt;refspec&gt;</code> é um opcional mais <code>+</code>, seguido pelo objeto da origem <code>&lt;src&gt;</code>, seguido de dois pontos <code>:</code>, seguido pelo destino da ref <code>&lt;dst&gt;</code>.</p>
<div class="paragraph">
<p>Geralmente <code>&lt;src&gt;</code> é o nome do ramo que você deseja impulsionar, pode ser qualquer "expressão SHA-1" arbitrária, como <code>master~4</code> ou <code>HEAD</code> (consulte <a href='{{< relurl "docs/gitrevisions/pt_BR" >}}'>gitrevisions[7]</a>).</p>
</div>
<div class="paragraph">
<p>O &lt;dst&gt; informa qual a "ref" no lado remoto será atualizado com este impulsionamento "push". Expressões arbitrárias não podem ser utilizadas aqui, uma "ref" real deve ser determinada. Caso o comando <code>git push [&lt;repositório&gt;]</code> sem nenhum argumento <code>&lt;refspec&gt;</code> estiver definido para atualizar alguma "ref" no destino com <code>&lt;src&gt;</code> com a variável de configuração <code>remote.&lt;repositório&gt;.push</code>, a parte do comando <code>:&lt;dst&gt;</code> pode ser omitida, este empulsionamento "push" atualizará uma "ref" onde <code>&lt;src&gt;</code> normalmente atualiza sem qualquer <code>&lt;refspec&gt;</code> na linha de comando. Caso contrário, a falta de <code>:&lt;dst&gt;</code> significa atualizar a mesma referência que o <code>&lt;src&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Caso o &lt;dst&gt; não comece com <code>refs/</code> (como <code>refs/heads/master</code> por exemplo), tentaremos inferir onde em <code>refs/*</code> no &lt;repositório&gt; de destino, ele pertença com base no tipo da &lt;src&gt; sendo impulsionado e caso o &lt;dst&gt; seja ambíguo.</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Caso o &lt;dst&gt; se refira inequivocamente a uma "ref" no &lt;repositório&gt; do ramo remoto, então faça um impulsionamento "push" nesta ref.</p>
</li>
<li>
<p>Caso o &lt;src&gt; seja resolvido para uma "ref" começando com <code>refs/heads/</code> ou <code>refs/tags/</code>, coloque um prefixo no &lt;dst&gt;.</p>
</li>
<li>
<p>Outras resoluções de ambiguidade podem ser adicionadas no futuro, mas, por enquanto, outros casos apresentarão um erro indicando o que tentamos e dependendo da configuração <code>advice.pushUnqualifiedRefname</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>), sugere qual <em>refs/ namespace</em> você possa querer impulsionar.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>O objeto referenciado por &lt;src&gt; é utilizado para atualizar a referência &lt;dst&gt; no lado remoto. Caso isso seja permitido, vai depender de onde em <code>refs/*</code> a referência &lt;dst&gt; vive como descrito com mais detalhes logo abaixo, nestas seções "update" indica que quaisquer modificações, exceto as exclusões, que serão descritos nas próximas seções, são tratadas de forma diferente.</p>
</div>
<div class="paragraph">
<p>O espaço de nomes <code>refs/heads/*</code> aceitarão apenas os objetos commit e será atualizado apenas caso eles possam avançar de forma rápida.</p>
</div>
<div class="paragraph">
<p>O espaço de nomes <code>refs/tags/*</code> aceitarão quaisquer tipos de objeto (como commits, árvores e bolhas que possam ser marcados) e quaisquer atualizações para eles serão rejeitadas.</p>
</div>
<div class="paragraph">
<p>É possível impulsionar qualquer tipo de objeto para qualquer espaço de nomes fora do <code>refs/{tags,heads}/*</code>. No caso das tags e dos commits, estes serão tratados como se fossem os commits dentro do <code>refs/heads/*</code> para os propósitos caso a atualização seja permitida.</p>
</div>
<div class="paragraph">
<p>Um avanço rápido dos commits e das tags fora do <code>refs/{tags,heads}/*</code> por exemplo, é permitido, mesmo nos casos onde o que está sendo acelerado não é um commit e sim um objeto da tag que aponte para um novo commit onde seja um avanço rápido do commit da última tag (ou commit) que está sendo substituindo. Também é permitida a reposição de uma tag por uma outra totalmente diferente, caso ela apontar para o mesmo commit, bem como ao impulsionar uma tag já descascada, ou seja, impulsionar o commit onde o objeto existente do tag aponte ou um novo objeto da tag onde o commit existente esteja apontando.</p>
</div>
<div class="paragraph">
<p>Os objetos da árvore e da bolha fora do <code>refs{tags,heads}/*</code> serão tratados da mesma maneira como se estivessem dentro do <code>refs/tags/*</code>, qualquer outra atualização deles será rejeitada.</p>
</div>
<div class="paragraph">
<p>Todas as regras descritas acima sobre o que não é permitido como uma atualização, podem ser substituídas adicionando um sinal opcional <code>+</code> inicial num "refspec" (ou utilizando a opção da linha de comando <code>--force</code>). A única exceção a isso é que nenhuma quantidade de imposição fará com que o espaço de nomes <code>refs/heads/*</code> aceite um objeto que não seja um commit. Os ganchos e configurações também podem substituir ou alterar estas regras, consulte, por exemplo, <code>receive.denyNonFastForwards</code> no <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> e <code>pre-receive</code> e <code>update</code> no <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>.</p>
</div>
<div class="paragraph">
<p>Fazer um impulsionamento "push" de um &lt;src&gt; vazio permite excluir o &lt;dst&gt; "ref" do repositório remoto. As exclusões sempre são aceitas sem um sinal <code>+</code> inicial no "refspec" (ou com a opção <code>--force</code>), exceto quando for proibido pela configuração ou pelos ganchos. Consulte <code>receive.denyDeletes</code> no <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> e <code>pre-receive</code> e <code>update</code> no <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>.</p>
</div>
<div class="paragraph">
<p>O "refspec" especial <code>:</code> (ou <code>+:</code> para permitir as atualizações sem avanço rápido) instrui o Git para enviar as ramificações "coincidentes": para cada ramificação que exista no lado local, o lado remoto é atualizado caso uma ramificação do o mesmo nome já exista.</p>
</div>
<div class="paragraph">
<p>A <code>tag &lt;tag&gt;</code> significa o mesmo que <code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push---all"> <a class="anchor" href="#git-push---all"></a>--all </dt>
<dt class="hdlist1" id="git-push---branches"> <a class="anchor" href="#git-push---branches"></a>--branches </dt>
<dd>
<p>impulsione todos os ramos (ou seja, refs em <code>refs/heads/</code>); não pode ser utilizado com outro &lt;refspec&gt;.</p>
</dd>
<dt class="hdlist1" id="git-push---prune"> <a class="anchor" href="#git-push---prune"></a>--prune </dt>
<dd>
<p>Remova as ramificações remotas que não possuam uma contraparte local. Uma ramificação remota <code>tmp</code> será removida caso uma ramificação local com o mesmo nome não existir mais por exemplo. Isso também respeita os "refespecs", por exemplo O comando <code>git push --prune remote refs/heads/*:refs/tmp/*</code> garantiria que o <code>refs/tmp/foo</code> remoto seja removido caso o <code>refs/heads/foo</code> não exista.</p>
</dd>
<dt class="hdlist1" id="git-push---mirror"> <a class="anchor" href="#git-push---mirror"></a>--mirror </dt>
<dd>
<p>Em vez de nomear cada "ref" para fazer o impulsionamento, determine que todos os refs no <code>refs/</code> (que incluem, mas não se limitam a <code>refs/heads/</code>, <code>refs/remotes/</code> e <code>refs/tags/</code>) sejam espelhados para o repositório remoto. As refs locais que foram recém-criadas serão enviadas para a extremidade remota, as refs que foram atualizadas localmente terão a sua atualização imposta no lado remoto e as refs que foram excluídas serão removidas remotamente. Esta é a predefinição caso a opção de configuração <code>remote.&lt;remoto&gt;.mirror</code> esteja definido.</p>
</dd>
<dt class="hdlist1" id="git-push--n"> <a class="anchor" href="#git-push--n"></a>-n </dt>
<dt class="hdlist1" id="git-push---dry-run"> <a class="anchor" href="#git-push---dry-run"></a>--dry-run </dt>
<dd>
<p>Faça tudo, exceto realmente enviar as atualizações.</p>
</dd>
<dt class="hdlist1" id="git-push---porcelain"> <a class="anchor" href="#git-push---porcelain"></a>--porcelain </dt>
<dd>
<p>Gere uma saída legível para uma máquina. A linha da condição geral para cada "ref" será separada por tabulação e encaminhada para o stdout em vez de stderr. Os nomes simbólicos completos das refs serão informados.</p>
</dd>
<dt class="hdlist1" id="git-push--d"> <a class="anchor" href="#git-push--d"></a>-d </dt>
<dt class="hdlist1" id="git-push---delete"> <a class="anchor" href="#git-push---delete"></a>--delete </dt>
<dd>
<p>Todas as refs listadas são excluídas do repositório remoto. É o mesmo que prefixar todos as refs com dois pontos.</p>
</dd>
<dt class="hdlist1" id="git-push---tags"> <a class="anchor" href="#git-push---tags"></a>--tags </dt>
<dd>
<p>Todas as refs no <code>refs/tags</code> são impulsionadas, além das "refspecs" que forem explicitamente listados na linha de comando.</p>
</dd>
<dt class="hdlist1" id="git-push---follow-tags"> <a class="anchor" href="#git-push---follow-tags"></a>--follow-tags </dt>
<dd>
<p>Impulsione todas as refs que seriam enviadas sem esta opção e também as tags anotadas no <code>refs/tags</code> que estão ausentes no ramo remoto, mas estão apontando para o "commit-ish" acessível a partir das referências sendo impulsionadas. Também pode ser definido com a variável de configuração <code>push.followTags</code>. Para mais informações, consulte <code>push.followTags</code> no <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-push---no-signed"> <a class="anchor" href="#git-push---no-signed"></a>--[no-]signed </dt>
<dt class="hdlist1" id="git-push---signedtruefalseif-asked"> <a class="anchor" href="#git-push---signedtruefalseif-asked"></a>--signed=(true|false|if-asked) </dt>
<dd>
<p>O GPG assina a solicitação impulsionamento para atualizar os <code>refs</code> no lado do recebimento permitindo que ele seja verificado pelos ganchos ou seja catalogado nos registros. Caso as opções <code>false</code> ou <code>--no-signed</code> sejam utilizadas, nenhuma tentativa de assinatura será feita. Caso as opções <code>true</code> ou <code>--signed</code> sejam utilizadas, o impulsionamento irá falhará caso o servidor não seja compatível com impulsionamentos assinados. Caso seja definido com <code>if-asked</code>, a assinatura só será realizada caso o servidor seja compatível com impulsionamentos assinados. O impulsionamento falhará caso a chamada atual para o comando <code>gpg --sign</code> falhe. Para obter detalhes sobre o recebimento na parte final, consulte <a href='{{< relurl "docs/git-receive-pack/pt_BR" >}}'>git-receive-pack[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-push---no-atomic"> <a class="anchor" href="#git-push---no-atomic"></a>--[no-]atomic </dt>
<dd>
<p>Utilize uma transação atômica no lado remoto, caso esteja disponível. Ou todas as refs são atualizadas ou, por erro, nenhuma será. Caso o servidor não seja compatível com impulsionamento atômico, o impulsionamento "push" irá falhar.</p>
</dd>
<dt class="hdlist1" id="git-push--oltopogt"> <a class="anchor" href="#git-push--oltopogt"></a>-o &lt;opção&gt; </dt>
<dt class="hdlist1" id="git-push---push-optionltopogt"> <a class="anchor" href="#git-push---push-optionltopogt"></a>--push-option=&lt;opção&gt; </dt>
<dd>
<p>Transmita a sequência informada para o servidor, que o repassa ao gancho de pré recebimento assim como o de pré recebimento. A sequência informada não deve conter um caractere <code>NUL</code> ou <code>LF</code>. Quando várias opções <code>--push-option=&lt;opção&gt;</code> são utilizadas, todas elas são enviadas ao outro lado para que sejam listadas na linha de comando. Quando nenhum comando <code>--push-option=&lt;option&gt;</code> é utilizado, então os valores da configuração da variável <code>push.pushOption</code> passam a ser utilizados.</p>
</dd>
<dt class="hdlist1" id="git-push---receive-packltgit-recebe-pacotegt"> <a class="anchor" href="#git-push---receive-packltgit-recebe-pacotegt"></a>--receive-pack=&lt;git-recebe-pacote&gt; </dt>
<dt class="hdlist1" id="git-push---execltgit-recebe-pacotegt"> <a class="anchor" href="#git-push---execltgit-recebe-pacotegt"></a>--exec=&lt;git-recebe-pacote&gt; </dt>
<dd>
<p>O caminho para o programa <em>git-receive-pack</em> na extremidade remota. Às vezes é útil ao enviar para um repositório remoto através do ssh e você não possui o programa no diretório no <code>$PATH</code> predefinido.</p>
</dd>
<dt class="hdlist1" id="git-push---no-force-with-lease"> <a class="anchor" href="#git-push---no-force-with-lease"></a>--[no-]force-with-lease </dt>
<dt class="hdlist1" id="git-push---force-with-leaseltrefnamegt"> <a class="anchor" href="#git-push---force-with-leaseltrefnamegt"></a>--force-with-lease=&lt;refname&gt; </dt>
<dt class="hdlist1" id="git-push---force-with-leaseltrefnamegtltexpectgt"> <a class="anchor" href="#git-push---force-with-leaseltrefnamegtltexpectgt"></a>--force-with-lease=&lt;refname&gt;:&lt;expect&gt; </dt>
<dd>
<p>Normalmente, o comando "git push" se recusa a atualizar uma "ref" remota que não seja um ancestral da "ref" local utilizada para substituí-la.</p>
<div class="paragraph">
<p>Esta opção substitui esta restrição caso o valor atual da "ref" remota seja o valor esperado. Caso contrário o "git push" vai falhar.</p>
</div>
<div class="paragraph">
<p>Imagine que você precise refazer o que já foi publicado. Você precisará ignorar a regra "deve avançar rapidamente" para substituir o histórico publicado originalmente através histórico que foi reformulado. Caso alguém construa no topo do seu histórico original enquanto você está fazendo um "rebase", o topo do ramo no ramo remoto pode avançar com o commit dela e impulsionar cegamente com o <code>--force</code> fará com que ela perca o trabalho dela.</p>
</div>
<div class="paragraph">
<p>Esta opção permite que você diga que vai esperar que o histórico que está sendo atualizando seja o que você reconstruiu com o "rebase" e vai querer substituir. Casi uma "ref" remota ainda aponte para um commit específico, você pode ter certeza que outras pessoas não fizeram nada com a "ref". É como fazer uma "concessão" na ref sem bloqueá-la diretamente, a "ref" remota será atualizada apenas caso a "concessão" ainda seja válida.</p>
</div>
<div class="paragraph">
<p>Somente a opção <code>--force-with-lease</code>, sem qualquer outra definição, protegerá todos as refs remotas que serão atualizadas, exigindo que o seu valor atual seja o mesmo que o ramo monitorado remotamente que temos para eles.</p>
</div>
<div class="paragraph">
<p>A opção <code>--force-with-lease=&lt;refname&gt;</code>, sem qualquer outro valor esperado, protegerá a "ref" que foi informado (sozinho), caso seja atualizado, exigindo que o seu valor atual seja o mesmo que o ramo monitorado remotamente que temos para isso.</p>
</div>
<div class="paragraph">
<p><code>--force-with-lease=&lt;refname&gt;:&lt;expect&gt;</code> protegerá o ref informado (sozinho), caso seja atualizado, exigindo que o seu valor atual seja o mesmo que o valor definido <code>&lt;expect &gt;</code> (que pode ser diferente do ramo monitorado remotamente que temos para o refname ou nem precisamos ter esse ramo monitorado de forma remota quando este formulário é utilizado). Caso <code>&lt;expect&gt;</code> esteja vazio, então a ref informada já não deve existir.</p>
</div>
<div class="paragraph">
<p>Observe que todas as formas diferentes da opção <code>--force-with-lease=&lt;refname&gt;:&lt;expect&gt;</code> que define o valor atual esperado para a "ref" de forma explicita, ainda são experimentais e sua semântica pode mudar à medida que adquiramos mais experiência com este recurso.</p>
</div>
<div class="paragraph">
<p>A opção <code>--no-force-with-lease</code> cancelará todos os <code>--force-with-lease</code> anteriores na linha de comando.</p>
</div>
<div class="paragraph">
<p>Uma observação geral sobre a segurança: utilizar esta opção sem um valor esperado, por exemplo, <code>--force-with-lease</code> ou <code>--force-with-lease=&lt;refname&gt;</code> interage muito mal com qualquer coisa que execute de forma implícita o comando <code>git fetch</code> do ramo remoto que será encaminhado para um processo de segundo plano, como o comando <code>git fetch origin</code> no seu repositório para um trabalho agendado "cronjob" por exemplo.</p>
</div>
<div class="paragraph">
<p>A proteção oferecida contra a opção <code>--force</code> é garantir que as subsequentes alterações onde a base do seu trabalho não sejam prejudicadas, porém isso será derrotado trivialmente caso algum processo em segundo plano estiver atualizando as refs em segundo plano. Não temos nada além das informações de monitoramento remoto, como uma heurística para as refs que você deve ter visto e está disposto a adotar.</p>
</div>
<div class="paragraph">
<p>Caso o seu editor ou um outro sistema esteja executando o comando <code>git fetch</code> no segundo plano para você, uma maneira de atenuar isso é simplesmente configurar um outro ramo remoto:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git remote add origin-push $(git config remote.origin.url)
git fetch origin-push</pre>
</div>
</div>
<div class="paragraph">
<p>Agora, quando o processo em segundo plano executar o comando <code>git fetch origin</code>, as referências no <code>origin-push</code> não serão atualizadas e portanto, comandos como:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git push --force-with-lease origin-push</pre>
</div>
</div>
<div class="paragraph">
<p>Irá falhar a menos que você execute manualmente o comando <code>git fetch origin-push</code>. É claro que esse método será totalmente derrotado por algo que execute o comando <code>git fetch --all</code>, neste caso, você precisa desativá-lo ou fazer algo mais tedioso como:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git fetch              # atualiza o 'master' remotamente
git tag base master    # marca o ponto da nossa base
git rebase -i master   # reescreve alguns commits
git push --force-with-lease=master:base master:master</pre>
</div>
</div>
<div class="paragraph">
<p>Crie uma tag <code>base</code> para as versões do código upstream que você viu e está disposto a sobrescrever por exemplo, depois reescreva o histórico e finalmente, imponha um impulsionamento "push" com as alterações para <code>master</code> caso a versão remota ainda esteja na <code>base</code>, independentemente se os seus ramos <code>remotes/origin/master</code> locais foram atualizados em segundo plano ou não.</p>
</div>
<div class="paragraph">
<p>Alternativamente, ao usar a opção <code>--force-if-includes</code> como uma opção auxiliar em conjunto com <code>--force-with-lease[=&lt;refname&gt;]</code> (sem dizer qual o ref exato do commit remoto, ou quais os refs remotos que estão sendo protegidos por exemplo) no momento do "push", irá verificar se as atualizações a partir dos refs monitorados remotamente tenham sido atualizados de forma implicita em segundo plano e se estão sendo integrados localmente antes de permitir uma atualização forçada.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push--f"> <a class="anchor" href="#git-push--f"></a>-f </dt>
<dt class="hdlist1" id="git-push---force"> <a class="anchor" href="#git-push---force"></a>--force </dt>
<dd>
<p>Normalmente, o comando se recusa a atualizar uma "ref" remota que não seja um ancestral da "ref" local utilizada para substituí-la. Além disso, quando a opção <code>--force-with-lease</code> é utilizada, o comando se recusa a atualizar uma "ref" remota cujo valor atual não corresponda ao esperado.</p>
<div class="paragraph">
<p>Esta opção desativa estas verificações e pode causar a perda do commit no repositório remoto; utilize com cuidado.</p>
</div>
<div class="paragraph">
<p>Observe que a opção <code>--force</code> se aplica a todos os refs que são impulsionados, portanto, utilizá-lo com <code>push.default</code> definido como <code>matching</code> ou com os vários impulsionamentos nos destinos configurados com <code>remote.*.push</code>, pode substituir as outras refs que não sejam o ramo atual (incluindo as refs locais que estão estritamente por trás de sua contraparte remota). Para impor um impulsionamento "push" em apenas um ramo, utilize um <code>+</code> na frente do "refspec" que será impulsionado (como <code>git push origin +master</code> para impor um impulsionamento "push" no ramo <code>master</code> por exemplo). Consulte a seção <code>&lt;refspec&gt;...</code> acima para obter mais detalhes.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push---no-force-if-includes"> <a class="anchor" href="#git-push---no-force-if-includes"></a>--[no-]force-if-includes </dt>
<dd>
<p>Impõem uma atualização apenas se o topo da ref monitorada remotamente estiver integrada localmente.</p>
<div class="paragraph">
<p>Esta opção permite uma checagem que verifica se o topo da referência monitorada remotamente é alcançável a partir de uma das entradas "reflog" do ramo local e feita com base nela para uma reescrita. A verificação assegura que quaisquer atualizações do ramo remoto foram incorporadas localmente, rejeitando a atualização forçada se não for esse o caso.</p>
</div>
<div class="paragraph">
<p>Nenhuma operação será feita caso a opção seja usada sem definir <code>--force-with-lease</code> ou se definir junto com <code>--force-with-lease=&lt;refname&gt;:&lt;expect&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Usando a opção <code>--no-force-if-includes</code> desativa este comportamento.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push---repoltrepositriogt"> <a class="anchor" href="#git-push---repoltrepositriogt"></a>--repo=&lt;repositório&gt; </dt>
<dd>
<p>Esta opção é equivalente ao argumento &lt;repositório&gt;. Caso ambos sejam utilizados, o argumento da linha de comandos terá a prioridade.</p>
</dd>
<dt class="hdlist1" id="git-push--u"> <a class="anchor" href="#git-push--u"></a>-u </dt>
<dt class="hdlist1" id="git-push---set-upstream"> <a class="anchor" href="#git-push---set-upstream"></a>--set-upstream </dt>
<dd>
<p>Para cada ramo atualizado ou impulsionada com êxito, adicione uma referência "upstream" (monitorado), utilizada sem argumento pelo <a href='{{< relurl "docs/git-pull/pt_BR" >}}'>git-pull[1]</a> e os outros comandos. Para mais informações, consulte <code>branch.&lt;nome&gt;.merge</code> no <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-push---no-thin"> <a class="anchor" href="#git-push---no-thin"></a>--[no-]thin </dt>
<dd>
<p>Estas opções são passadas para o <a href='{{< relurl "docs/git-send-pack/pt_BR" >}}'>git-send-pack[1]</a>. Uma pequena transferência "thin" reduz significativamente a quantidade dos dados enviados quando o remetente e o destinatário compartilham muito dos mesmos objetos em comum. A predefinição é <code>--thin</code>.</p>
</dd>
<dt class="hdlist1" id="git-push--q"> <a class="anchor" href="#git-push--q"></a>-q </dt>
<dt class="hdlist1" id="git-push---quiet"> <a class="anchor" href="#git-push---quiet"></a>--quiet </dt>
<dd>
<p>Suprima tudo o que for gerado, incluindo a listagem das atualizações das refs, a menos que um erro aconteça. O progresso não é relatado para o fluxo de erro predefinido.</p>
</dd>
<dt class="hdlist1" id="git-push--v"> <a class="anchor" href="#git-push--v"></a>-v </dt>
<dt class="hdlist1" id="git-push---verbose"> <a class="anchor" href="#git-push---verbose"></a>--verbose </dt>
<dd>
<p>Rode de forma loquaz.</p>
</dd>
<dt class="hdlist1" id="git-push---progress"> <a class="anchor" href="#git-push---progress"></a>--progress </dt>
<dd>
<p>É predefinido que a condição geral do progresso seja relatada no fluxo de erros quando estiver conectado num terminal, a menos que <code>-q</code> seja utilizado. Esta opção impõem a condição geral do progresso, mesmo que o fluxo de erro predefinido não seja direcionado para um terminal.</p>
</dd>
<dt class="hdlist1" id="git-push---no-recurse-submodules"> <a class="anchor" href="#git-push---no-recurse-submodules"></a>--no-recurse-submodules </dt>
<dt class="hdlist1" id="git-push---recurse-submodulescheckon-demandonlyno"> <a class="anchor" href="#git-push---recurse-submodulescheckon-demandonlyno"></a>--recurse-submodules=check|on-demand|only|no </dt>
<dd>
<p>Pode ser utilizado para garantir que todos os submódulo dos commits utilizadas pelas revisões que serão enviadas estejam disponíveis numa ramificação monitorada remotamente. Caso <em>check</em> seja utilizado, o Git verificará se todos os commit do submódulo que foram alterados nas revisões que serão enviadas estão disponíveis em pelo menos um ramo remoto do submódulo. Caso algum commit esteja ausente, o push será abortado e encerrará com uma condição diferente de zero. Caso <em>on demand</em> seja utilizado, todos os submódulos que foram alterados nas revisões que serão impulsionadas, serão impulsionadas. Caso <em>on demand</em> não puder enviar todas as revisões necessárias, ela também será abortada e sairá com uma condição diferente de zero. Caso <em>only</em> seja utilizado, todos os submódulos serão impulsionados enquanto o super projeto não seja deixado sem impulsionamento. Um valor de <em>no</em> ou utilizando a opção <code>--no-recurse-submodules</code> pode ser utilizado para substituir a variável de configuração <code>push.recurseSubmodules</code> quando nenhuma recursão do submódulo for necessária.</p>
<div class="paragraph">
<p>Ao usar <em>on-demand</em> ou <em>only</em>, caso um submódulo tenha uma configuração "push.recurseSubmodules={on-demand,only}" ou "submodule.recurse", haverá uma recursão adicional. Nesse caso, "only" é tratado como "on-demand"(sob demanda).</p>
</div>
</dd>
<dt class="hdlist1" id="git-push---no-verify"> <a class="anchor" href="#git-push---no-verify"></a>--[no-]verify </dt>
<dd>
<p>Alterna o gancho "pre-push" (consulte <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>). A opção <code>--verify</code> é a predefinição, dando ao gancho a chance de impedir o impulsionamento. Com a opção --no-verify, o gancho é completamente ignorado.</p>
</dd>
<dt class="hdlist1" id="git-push--4"> <a class="anchor" href="#git-push--4"></a>-4 </dt>
<dt class="hdlist1" id="git-push---ipv4"> <a class="anchor" href="#git-push---ipv4"></a>--ipv4 </dt>
<dd>
<p>Utilize apenas os endereços IPv4, ignorando os endereços IPv6.</p>
</dd>
<dt class="hdlist1" id="git-push--6"> <a class="anchor" href="#git-push--6"></a>-6 </dt>
<dt class="hdlist1" id="git-push---ipv6"> <a class="anchor" href="#git-push---ipv6"></a>--ipv6 </dt>
<dd>
<p>Utilize apenas os endereços IPv6, ignorando os endereços IPv4.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git_urls"><a class="anchor" href="#_git_urls"></a>GIT URLS<a id="URLS"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Em geral as URLs contêm informações sobre o protocolo de transporte, o endereço do servidor remoto e o caminho para o repositório. Dependendo do protocolo de transporte, algumas dessas informações podem estar ausentes.</p>
</div>
<div class="paragraph">
<p>O Git suporta os protocolos ssh, git, http e https (além do ftp e ftps podem ser utilizados para capturar, porém é ineficiente e obsoleto; não utilize).</p>
</div>
<div class="paragraph">
<p>O transporte nativo (ou seja, git:// URL) não faz a autenticação e deve ser utilizado com cuidado em redes sem segurança.</p>
</div>
<div class="paragraph">
<p>As seguintes sintaxes podem ser utilizadas com eles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ssh://[user@]host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>git://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>http[s]://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>ftp[s]://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Uma sintaxe alternativa como scp também pode ser utilizada com o protocolo ssh:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[user@]host.xz:caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Essa sintaxe apenas é reconhecida caso não haja barras antes dos primeiros dois pontos. Isso ajuda a diferenciar um caminho local que contém dois pontos. Por exemplo, o caminho local <code>foo:bar</code> pode ser utilizado como um caminho absoluto ou <code>./foo:bar</code> para evitar ser mal interpretado como uma url ssh.</p>
</div>
<div class="paragraph">
<p>Os protocolos ssh e git também oferecem suporte à expansão do ~nome do usuário:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ssh://[user@]host.xz[:port]/~[user]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>git://host.xz[:port]/~[user]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>[user@]host.xz:/~[user]/caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para os repositórios locais, as seguintes sintaxes podem ser utilizadas que também são compatíveis de forma nativa pelo Git:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>file:///caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Estas duas sintaxes são basicamente equivalentes, exceto durante a clonagem, quando a primeira implica no uso da opção <code>--local</code>. Para mais detalhes, consulte <a href='{{< relurl "docs/git-clone/pt_BR" >}}'>git-clone[1]</a>.</p>
</div>
<div class="paragraph">
<p>O <em>git clone</em>, <em>git fetch</em> e <em>git pull</em>, mas não o <em>git push</em>, também aceitarão um arquivo do pacote adequado. Consulte <a href='{{< relurl "docs/git-bundle/pt_BR" >}}'>git-bundle[1]</a>.</p>
</div>
<div class="paragraph">
<p>Quando o Git não sabe como lidar com um determinado protocolo de transporte, quando existe, ele tenta usar o auxiliar <code>remote-&lt;transporte&gt;</code>. Para os repositórios locais, as seguintes sintaxes podem ser utilizadas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&lt;transporte&gt;::&lt;endereço&gt;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>onde &lt;endereço&gt; pode ser um caminho, um servidor e um caminho ou uma sequência arbitrária semelhante a uma URL reconhecida por um auxiliar remoto em específico que está sendo chamado. Para mais detalhes, consulte <a href='{{< relurl "docs/gitremote-helpers/pt_BR" >}}'>gitremote-helpers[7]</a>.</p>
</div>
<div class="paragraph">
<p>Se houver um grande número de repositórios remotos com nomes semelhantes e caso queira usar um formato diferente para eles (de modo que as URLs utilizadas sejam reescritas nas URLs que funcionam), você poderá criar uma seção de configuração da opção:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "&lt;url da base atual&gt;"]
		insteadOf = &lt;a url da outra base&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "git://git.host.xz/"]
		insteadOf = host.xz:/path/to/
		insteadOf = work:</pre>
</div>
</div>
<div class="paragraph">
<p>uma URL como "work:repo.git" ou como "host.xz:/caminho/para/o/repositório.git" será reescrito em qualquer contexto onde a URL seja "git://git.host.xz/repo.git".</p>
</div>
<div class="paragraph">
<p>Caso queira reescrever apenas as URLs para envio por "push" (impulsionamento), é possível criar uma seção de configuração da opção:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "&lt;url da base atual&gt;"]
		pushInsteadOf = &lt;a url da outra base&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "ssh://exemplo.org/"]
		pushInsteadOf = git://exemplo.org/</pre>
</div>
</div>
<div class="paragraph">
<p>uma URL como "git://exemplo.org/caminho/para/o/repositório.git" será reescrito para "ssh://exemplo.org/caminho/para/o/repositório.git" para os "pushes" (impulsionamentos), porém os "pulls" (obtenções) ainda usarão a URL original.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_remotos"><a class="anchor" href="#_remotos"></a>REMOTOS<a id="REMOTOS"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>O nome de um dos seguintes pode ser usado em vez de uma URL como argumento do <code>&lt;repositório&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>um ramo remoto no arquivo de configuração do Git: <code>$GIT_DIR/config</code>,</p>
</li>
<li>
<p>um arquivo no diretório <code>$GIT_DIR/remotes</code> ou</p>
</li>
<li>
<p>um arquivo no diretório <code>$GIT_DIR/branches</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tudo isso também permite seja omitido o refspec da linha de comando, pois cada um contém um refspec que o git utilizará de maneira predefinida.</p>
</div>
<div class="sect2">
<h3 id="_ramo_remoto_nomeado_no_arquivo_de_configuração"><a class="anchor" href="#_ramo_remoto_nomeado_no_arquivo_de_configuração"></a>Ramo remoto nomeado no arquivo de configuração</h3>
<div class="paragraph">
<p>Você pode optar por informar o nome de um ramo remoto que você configurou anteriormente usando <a href='{{< relurl "docs/git-remote/pt_BR" >}}'>git-remote[1]</a>, <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> ou até mesmo uma edição manual no arquivo <code>$GIT_DIR/config</code>. A URL deste ramo remoto será usado para acessar o repositório. É predefinido que o "refspec" deste ramo remoto será usado quando você não informar um refspec na linha de comando. A entrada no arquivo de configuração ficaria assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[remote "&lt;nome&gt;"]
		url = &lt;URL&gt;
		pushurl = &lt;pushurl&gt;
		push = &lt;refspec&gt;
		fetch = &lt;refspec&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>O <code>&lt;pushurl&gt;</code> é usado somente para envios. É opcional e o padrão é <code>&lt;URL&gt;</code>. O envio para um controle remoto afeta todos os pushurls definidos ou todos as urls definidas se não houver pushurls definidos. No entanto, o Fetch só buscará a primeira url definida caso haja várias urls definidas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arquivo_nomeado_no_git_dirremotes"><a class="anchor" href="#_arquivo_nomeado_no_git_dirremotes"></a>Arquivo nomeado no <code>$GIT_DIR/remotes</code></h3>
<div class="paragraph">
<p>Você pode optar por fornecer o nome de um arquivo em <code>$GIT_DIR/remotes</code>. A URL neste arquivo será utilizada para acessar o repositório. O "refspec" neste arquivo será utilizado como uma predefinição quando você não informar um "refspec" na linha de comando. Este arquivo deve ter o seguinte formato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	URL: um dos formatos da URL acima
	Push: &lt;refspec&gt;
	Pull: &lt;refspec&gt;</pre>
</div>
</div>
<div class="paragraph">
<p><code>Push:</code> as linhas são usadas pelo comando <em>git push</em> e <code>Pull:</code> as linhas são usadas pelo comando <em>git pull</em> e <em>git fetch</em>. Várias linhas <code>Push:</code> e <code>Pull:</code> podem ser utilizadas para mapeamentos adicionais das ramificações.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arquivo_informado_em_git_dirbranches"><a class="anchor" href="#_arquivo_informado_em_git_dirbranches"></a>Arquivo informado em <code>GIT_DIR/branches</code></h3>
<div class="paragraph">
<p>Você pode decidir entre informar o nome de um arquivo no <code>$GIT_DIR/branches</code>. A URL neste arquivo será utilizada para acessar o repositório. Este arquivo deve ter o seguinte formato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	&lt;URL&gt;#&lt;head&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>A <code>&lt;URL&gt;</code> é necessária; <code>#&lt;head&gt;</code> é opcional.</p>
</div>
<div class="paragraph">
<p>Dependendo da operação, o git usará um dos seguintes refspecs, caso nenhum seja utilizado na linha de comando. O <code>&lt;ramo&gt;</code> (ramo) é o nome deste arquivo no <code>$GIT_DIR/branches</code> e <code>&lt;head&gt;</code> retorna a predefinição para <code>master</code>.</p>
</div>
<div class="paragraph">
<p>O git fetch usa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	refs/heads/&lt;head&gt;:refs/heads/&lt;ramo&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>git push</code> usa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	HEAD:refs/heads/&lt;head&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_saída"><a class="anchor" href="#_saída"></a>SAÍDA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O que é gerado através do "git push" depende do método de transporte utilizado; Esta seção descreve a saída gerada durante o impulsionamento através do protocolo Git (localmente ou através do ssh).</p>
</div>
<div class="paragraph">
<p>Durante um "push" a condição é que seja gerado em formato de tabela, com cada linha representando a condição de um único "ref". Cada linha é uma forma de:</p>
</div>
<div class="listingblock">
<div class="content">
<pre> &lt;flag&gt; &lt;resumo&gt; &lt;from&gt; -&gt; &lt;to&gt; (&lt;reason&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>Caso a opção <code>--porcelain</code> seja utilizado, cada linha da saída terá o formato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre> &lt;flag&gt; \t &lt;from&gt;:&lt;to&gt; \t &lt;summary&gt; (&lt;reason&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>A condição das referências atualizadas é exibido apenas caso a opção <code>--porcelain</code> ou <code>--verbose</code> seja utilizada.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-sinalizarsinalizaoindicaomarcaomarcador"> <a class="anchor" href="#git-push-sinalizarsinalizaoindicaomarcaomarcador"></a>sinalizar, sinalização, indicação, marcação, marcador </dt>
<dd>
<p>Um único caractere indicando a condição da referência:</p>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-space"> <a class="anchor" href="#git-push-space"></a>(space) </dt>
<dd>
<p>para um push com avanço rápido bem sucedido;</p>
</dd>
<dt class="hdlist1" id="git-push-codecode"> <a class="anchor" href="#git-push-codecode"></a><code>+</code> </dt>
<dd>
<p>para uma imposição de atualização bem sucedida;</p>
</dd>
<dt class="hdlist1" id="git-push-code-code"> <a class="anchor" href="#git-push-code-code"></a><code>-</code> </dt>
<dd>
<p>para uma "ref" que foi excluída com sucesso;</p>
</dd>
<dt class="hdlist1" id="git-push-codecode-1"> <a class="anchor" href="#git-push-codecode-1"></a><code>*</code> </dt>
<dd>
<p>para uma nova "ref" enviada com sucesso;</p>
</dd>
<dt class="hdlist1" id="git-push-codecode-1-1"> <a class="anchor" href="#git-push-codecode-1-1"></a><code>!</code> </dt>
<dd>
<p>para uma "ref"que foi rejeitado ou não conseguiu realizar o impulsionamento "push"; e</p>
</dd>
<dt class="hdlist1" id="git-push-codecode-1-1-1"> <a class="anchor" href="#git-push-codecode-1-1-1"></a><code>=</code> </dt>
<dd>
<p>para uma "ref" que estava atualizada e não precisava do impulsionamento "push".</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-push-resumo"> <a class="anchor" href="#git-push-resumo"></a>resumo </dt>
<dd>
<p>Para uma "ref" impulsionada com sucesso, o resumo mostra os valores antigos e os novos da "ref" num formato adequado para a utilização como argumento para o comando <code>git log</code> (isso é <code>&lt;antigo&gt;..&lt;novo&gt;</code> na maioria dos casos, e <code>&lt;antigo&gt;...&lt;novo&gt;</code> para as atualizações impostas pelo avanço rápido).</p>
<div class="paragraph">
<p>Para uma atualização que falhou, mais detalhes serão dados:</p>
</div>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-rejeitado"> <a class="anchor" href="#git-push-rejeitado"></a>rejeitado </dt>
<dd>
<p>O Git não tenta encaminhar a "ref" de forma alguma, geralmente porque não é um avanço rápido e você não impôs a atualização.</p>
</dd>
<dt class="hdlist1" id="git-push-rejeitadoremotamente"> <a class="anchor" href="#git-push-rejeitadoremotamente"></a>rejeitado remotamente </dt>
<dd>
<p>Quando o lado remoto recusa a atualização. Geralmente cautilizada por um gancho no lado remoto ou porque o repositório remoto possui uma das seguintes opções de segurança em vigor: <code>receive.denyCurrentBranch</code> (para um <code>push</code> feiro num ramo verificado), <code>receive.denyNonFastForwards</code> (para atualizações impostas ou rápidas), <code>receive.denyDeletes</code> ou <code>receive.denyDeleteCurrent</code>. Consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-push-falharemota"> <a class="anchor" href="#git-push-falharemota"></a>falha remota </dt>
<dd>
<p>O lado remoto não relatou a atualização bem-sucedida da "ref", talvez por causa de um erro temporário, uma interrupção na conexão da rede ou um outro erro transitório.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1" id="git-push-de"> <a class="anchor" href="#git-push-de"></a>de </dt>
<dd>
<p>O nome do "ref" local que está sendo impulsionado, menos o seu prefixo <code>refs/&lt;tipo&gt;/</code>. No caso de exclusão, o nome do "ref" local é omitido.</p>
</dd>
<dt class="hdlist1" id="git-push-para"> <a class="anchor" href="#git-push-para"></a>para </dt>
<dd>
<p>O nome ref remoto sendo atualizado, menos o seu prefixo <code>refs/&lt;tipo&gt;/</code>.</p>
</dd>
<dt class="hdlist1" id="git-push-motivo"> <a class="anchor" href="#git-push-motivo"></a>motivo </dt>
<dd>
<p>Uma explicação legível para pessoas. No caso dos refs que forem enviados com sucesso, nenhuma explicação é necessária. Para um "ref" que falhou, o motivo do fracasso então é descrito.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nota_sobre_avanços_rápidos"><a class="anchor" href="#_nota_sobre_avanços_rápidos"></a>NOTA SOBRE AVANÇOS RÁPIDOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quando uma atualização altera um ramo (ou geralmente uma "ref") que costumava apontar para o commit <em>A</em> que aponta para outro commit <em>B</em>, é chamado de atualização de avanço rápido apenas e somente se <em>B</em> for descendente de <em>A</em>.</p>
</div>
<div class="paragraph">
<p>Em uma atualização de avanço rápido de A para B, o conjunto dos commits que o commit original A que construiu sobre ela é um subconjunto dos commits que o novo commit B constrói sobre ela. Portanto, não perde nenhum histórico.</p>
</div>
<div class="paragraph">
<p>Por outro lado, uma atualização sem avanço rápido perderá o histórico. Por exemplo, suponha que você e uma outra pessoa tenham iniciado o mesmo commit <em>X</em> e você construiu um histórico que leva ao commit <em>B</em>, enquanto a outra pessoa construiu um histórico que leva ao commit <em>A</em>. O histórico ficaria assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>      B
     /
 ---X---A</pre>
</div>
</div>
<div class="paragraph">
<p>Além disso, suponha que a outra pessoa já tenha enviado as alterações que levam "A" de volta ao repositório original, a partir do qual vocês dois obtiveram o commit "X" original.</p>
</div>
<div class="paragraph">
<p>O impulsionamento feito pela outra pessoa atualizou o ramo que costumava apontar no commit <em>X</em> para apontar no commit <em>A</em>. É um avanço rápido.</p>
</div>
<div class="paragraph">
<p>Porém caso você tente impulsionar, você tentará atualizar o ramo (que agora aponta para <em>A</em>) com o commit <em>B</em>. Isso <em>não</em> fa o avanço rapido. Se você fez isso, as alterações introduzidas pelo commit <em>A</em> serão perdidas, porque todo mundo começará a construir em cima do <em>B</em>.</p>
</div>
<div class="paragraph">
<p>É predefinido que o comando não permita uma atualização que não seja um avanço rápido para impedir esta perda do histórico.</p>
</div>
<div class="paragraph">
<p>Caso não queira perder o seu trabalho (histórico <em>X</em> para <em>B</em>) ou o trabalho da outra pessoa (histórico de <em>X</em> para <em>A</em>), é necessário primeiro buscar o histórico no repositório, criar um histórico que contenha as alterações feitas por ambas as partes e que impulsione o resultado de volta.</p>
</div>
<div class="paragraph">
<p>É possível executar o comando "git pull", para resolver os possíveis conflitos e comando "git push" o resultado. Um comando "git pull" criará um commit da mesclagem <em>C</em> entre os commits <em>A</em> e <em>B</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>      B---C
     /   /
 ---X---A</pre>
</div>
</div>
<div class="paragraph">
<p>A atualização de "A" com a consolidação resultante da mesclagem, avançará rapidamente e o seu envio será aceito.</p>
</div>
<div class="paragraph">
<p>Como alternativa, você pode reconstruir a sua alteração entre <em>X</em> e o <em>B</em> no topo de <em>A</em>, com o comando "git pull --rebase", e fazer o impulsionamento do resultado de volta. Uma reconstrução da fundação "rebase" criará um novo commit <em>D</em> que gera a alteração entre <em>X</em> e <em>B</em> em cima de <em>A</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>      B   D
     /   /
 ---X---A</pre>
</div>
</div>
<div class="paragraph">
<p>Novamente, a atualização de <em>A</em> com este commit avançará rapidamente e o seu envio será aceito.</p>
</div>
<div class="paragraph">
<p>Há uma outra situação comum onde é possível encontrar uma rejeição sem avanço rápido ao tentar enviar através do "push", e é possível mesmo quando você está impulsionando para um repositório que ninguém mais faz impulsionamentos. Depois de enviar o commit <em>A</em> (na primeira foto desta seção), substitua-o pelo comando "git commit --amend" para produzir o commit <em>B</em> e tente realizar o "push", porque foi esquecido que já foi feito um push para <em>A</em>. Neste caso e somente caso tenha certeza que ninguém fez a busca pelo seu commit <em>A</em> anterior (e começou a construir em cima ele), execute o comando "git push --force" para substituí-lo. Em outras palavras, o comando "git push --force" é um método reservado para o caso onde você queira perder o histórico.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-push-codegitpushcode"> <a class="anchor" href="#git-push-codegitpushcode"></a><code>git push</code> </dt>
<dd>
<p>Funciona como <code>git push &lt;remoto&gt;</code>, onde &lt;remoto&gt; é o ramo remoto da ramificação atual (ou <code>origin</code> (origem), caso nenhum ramo remoto estiver configurado para a ramificação atual).</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushorigincode"> <a class="anchor" href="#git-push-codegitpushorigincode"></a><code>git push origin</code> </dt>
<dd>
<p>Sem uma configuração adicional, envia a ramificação atual para a upstream configurada (a variável de configuração <code>branch.&lt;name&gt;.merge</code>) caso ela tenha o mesmo nome que o ramo atual e os erros ocorrerem sem qualquer outro impulsionamento.</p>
<div class="paragraph">
<p>O comportamento predefinido deste comando quando nenhum &lt;refspec&gt; for informado, pode ser configurado definindo a opção <code>push</code> do ramo remoto ou a variável de configuração <code>push.default</code>.</p>
</div>
<div class="paragraph">
<p>Por exemplo, para utilizar como predefinido apenas no ramo atual para <code>origin</code>, utilize <code>git config remote.origin.push HEAD</code>. Qualquer &lt;refspec&gt; válido (como os exemplos abaixo) pode ser configurado como a predefinição para <code>git push origin</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-push-codegitpushorigincode-1"> <a class="anchor" href="#git-push-codegitpushorigincode-1"></a><code>git push origin :</code> </dt>
<dd>
<p>Impulsiona (push) as ramificações "que coincidam" para <code>origin</code>. Consulte o &lt;refspec&gt; na seção <a href="#OPTIONS">OPTIONS</a> acima para obter uma descrição dos ramos "coincidentes".</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginmastercode"> <a class="anchor" href="#git-push-codegitpushoriginmastercode"></a><code>git push origin master</code> </dt>
<dd>
<p>Encontre uma "ref" que coincida com o <code>master</code> no repositório da origem (provavelmente encontrará <code>refs/heads/master</code>) e atualize a mesma "ref" (<code>refs/heads/master</code> por exemplo) no repositório <code>origin</code> com ela . Caso o <code>master</code> não existisse remotamente, ele seria criado.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginHEADcode"> <a class="anchor" href="#git-push-codegitpushoriginHEADcode"></a><code>git push origin HEAD</code> </dt>
<dd>
<p>Uma maneira prática de enviar a ramificação atual com o mesmo nome no ramo remoto.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushmothershipmastersatellitemasterdevsatellitedevcode"> <a class="anchor" href="#git-push-codegitpushmothershipmastersatellitemasterdevsatellitedevcode"></a><code>git push mothership master:satellite/master dev:satellite/dev</code> </dt>
<dd>
<p>Utilize a fonte "ref" que coincida com <code>master</code> (<code>refs/heads/ master</code> por exemplo) para atualizar a "ref" que coincida com <code>satellite/master</code> (provavelmente <code>refs/remotes/satellite/master</code>) no repositório <code>mothership</code>; faça o mesmo para <code>dev</code> e <code>satellite/dev</code>.</p>
<div class="paragraph">
<p>Consulte a seção que descreve <code>&lt;refspec&gt; ...</code> acima para uma discussão sobre a combinação semântica.</p>
</div>
<div class="paragraph">
<p>Isto serve para emular o comando <code>git fetch</code> executado na <code>mothership</code> utilizando o <code>git push</code> que é executado na direção oposta para integrar o trabalho realizado no <code>satellite</code> e geralmente é necessário quando só é possível fazer a conexão num sentido (ou seja, o satélite pode fazer uma conexão ssh com a nave mãe "mothership" mas a nave mãe não pode iniciar a conexão com o satélite porque este está atrás de um firewall ou não está executando o sshd (servidor ssh)).</p>
</div>
<div class="paragraph">
<p>Depois de executar o comando <code>git push</code> na máquina do <code>satellite</code>, você entraria na <code>mothership</code> e executaria o comando <code>git merge</code> lá para concluir a emulação do comando <code>git pull</code> executada na <code>mothership</code> para obter as alterações feitas no "satellite".</p>
</div>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginHEADmastercode"> <a class="anchor" href="#git-push-codegitpushoriginHEADmastercode"></a><code>git push origin HEAD: master</code> </dt>
<dd>
<p>Envie o ramo atual para a referência remota que coincida com <code>master</code> no repositório <code>origin</code>. Este formulário é conveniente para impulsionar o ramo atual sem pensar no nome local.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginmasterrefsheadsexperimentalcode"> <a class="anchor" href="#git-push-codegitpushoriginmasterrefsheadsexperimentalcode"></a><code>git push origin master:refs/heads/experimental</code> </dt>
<dd>
<p>Crie o ramo <code>experimental</code> no repositório <code>origin</code> copiando o ramo <code>master</code> atual. Este formulário é necessário apenas para criar um novo ramo ou a tag no repositório remoto quando o nome local e o nome remoto forem diferentes; caso contrário, o nome da "ref" por si só funcionará.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushoriginexperimentalcode"> <a class="anchor" href="#git-push-codegitpushoriginexperimentalcode"></a><code>git push origin :experimental</code> </dt>
<dd>
<p>Encontre uma "ref" que coincida com <code>experimental</code> no repositório <code>origin</code> (<code>refs/heads/experimental</code> por exemplo) e exclua-a.</p>
</dd>
<dt class="hdlist1" id="git-push-codegitpushorigindevmastercode"> <a class="anchor" href="#git-push-codegitpushorigindevmastercode"></a><code>git push origin +dev:master</code> </dt>
<dd>
<p>Atualize o ramo principal na origem do repositório com o ramo <em>dev</em>, permitindo atualizações sem o avanço rápido. <strong>Isso pode deixar os commits sem referência pendentes no repositório de origem.</strong> Considere a seguinte situação, onde um avanço rápido não seja possível:</p>
<div class="listingblock">
<div class="content">
<pre>	    o---o---o---A---B  origin/master
		     \
		      X---Y---Z  dev</pre>
</div>
</div>
<div class="paragraph">
<p>O comando acima alteraria o repositório de origem para</p>
</div>
<div class="listingblock">
<div class="content">
<pre>		      A---B  (ramo sem nome)
		     /
	    o---o---o---X---Y---Z  master</pre>
</div>
</div>
<div class="paragraph">
<p>Os commits <em>A</em> e <em>B</em> não pertenceriam mais a um ramo com um nome simbólico, portanto, seriam inacessíveis. Como tal, estes commits seriam removidos por um comando <code>git gc</code> no repositório de origem.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_segurança"><a class="anchor" href="#_segurança"></a>SEGURANÇA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os protocolos de busca e envio não foram projetados para impedir que um lado roube os dados do outro repositório que não deveriam ser compartilhado. Caso tenha dados particulares que precisam ser protegidos de um par malicioso, a sua melhor opção é armazená-los em um outro repositório. Isso se aplica aos clientes e aos servidores. Em particular, os espaço de nomes em um servidor não são eficazes para o controle de acesso de leitura; você só deve conceder acesso de leitura a um espaço de nomes para os clientes que você confiaria o acesso de leitura para todo o repositório.</p>
</div>
<div class="paragraph">
<p>Os vetores de ataque informados são os seguintes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A vítima envia as linhas "have" anunciando as IDs dos objetos que possui, que não são explicitamente planejados para serem compartilhados, porém podem ser usados para otimizar a transferência caso o par também os tenha. O atacante escolhe um ID do objeto <em>X</em> para roubar e envia uma "ref" para <em>X</em>, porém não é necessário enviar o conteúdo do <em>X</em> porque a vítima já o possui. Agora a vítima acredita que o atacante tem o <em>X</em> e depois envia seu conteúdo de volta ao atacante. (Esse ataque é mais simples para um cliente executar em um servidor, criando uma "ref" para <em>X</em> no espaço de nomes onde o cliente tem acesso e em seguida, buscando-o. A maneira mais provável de um servidor executá-lo em um cliente é "mesclar" <em>X</em> em um ramo público e esperar que o usuário faça um trabalho adicional neste ramo, enviá-lo de volta ao servidor sem perceber a mesclagem.)</p>
</li>
<li>
<p>Como no item 1, o atacante escolhe um ID do objeto <em>X</em> para roubar. A vítima envia um objeto <em>Y</em> que o atacante já possui e o atacante afirma falsamente ter <em>X</em> e não <em>Y</em>; portanto, a vítima envia <em>Y</em> como um delta contra <em>X</em>. O delta revela as regiões de <em>X</em> que são semelhantes para <em>Y</em> ao atacante.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuração"><a class="anchor" href="#_configuração"></a>CONFIGURAÇÃO</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>pt_BR/includes/cmd-config-section-all.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>pt_BR/config/push.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>